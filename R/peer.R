# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

##   Generated via the command line invocation:
##	 swig -c++ -r -o peer_wrap.cpp -I../External -I.. peer.i


#                         srun.swg                            #
#
# This is the basic code that is needed at run time within R to
# provide and define the relevant classes.  It is included
# automatically in the generated code by copying the contents of
# srun.swg into the newly created binding code.


# This could be provided as a separate run-time library but this
# approach allows the code to to be included directly into the
# generated bindings and so removes the need to have and install an
# additional library.  We may however end up with multiple copies of
# this and some confusion at run-time as to which class to use. This
# is an issue when we use NAMESPACES as we may need to export certain
# classes.

######################################################################

if(length(getClassDef("RSWIGStruct")) == 0) 
  setClass("RSWIGStruct", representation("VIRTUAL"))



if(length(getClassDef("ExternalReference")) == 0) 
# Should be virtual but this means it loses its slots currently
#representation("VIRTUAL")
  setClass("ExternalReference", representation( ref = "externalptr"))



if(length(getClassDef("NativeRoutinePointer")) == 0) 
  setClass("NativeRoutinePointer", 
              representation(parameterTypes = "character",
                             returnType = "character",
                             "VIRTUAL"), 
              contains = "ExternalReference")

if(length(getClassDef("CRoutinePointer")) == 0) 
  setClass("CRoutinePointer", contains = "NativeRoutinePointer")


if(length(getClassDef("EnumerationValue")) == 0) 
  setClass("EnumerationValue", contains = "integer")


if(!isGeneric("copyToR")) 
 setGeneric("copyToR",
            function(value, obj = new(gsub("Ref$", "", class(value)))) 
               standardGeneric("copyToR"
           ))

setGeneric("delete", function(obj) standardGeneric("delete"))


SWIG_createNewRef = 
function(className, ..., append = TRUE)
{
  f = get(paste("new", className, sep = "_"), mode = "function")

  f(...)
}

if(!isGeneric("copyToC")) 
 setGeneric("copyToC", 
             function(value, obj = RSWIG_createNewRef(class(value)))
              standardGeneric("copyToC"
            ))


# 
defineEnumeration =
function(name, .values, where = topenv(parent.frame()), suffix = "Value")
{
   # Mirror the class definitions via the E analogous to .__C__
  defName = paste(".__E__", name, sep = "")
  assign(defName,  .values,  envir = where)

  if(nchar(suffix))
    name = paste(name, suffix, sep = "")

  setClass(name, contains = "EnumerationValue", where = where)
}

enumToInteger <- function(name,type)
{
   if (is.character(name)) {
   ans <- as.integer(get(paste(".__E__", type, sep = ""))[name])
   if (is.na(ans)) {warning("enum not found ", name, " ", type)}
   ans
   } 
}

enumFromInteger =
function(i,type)
{
  itemlist <- get(paste(".__E__", type, sep=""))
  names(itemlist)[match(i, itemlist)]
}

coerceIfNotSubclass =
function(obj, type) 
{
    if(!is(obj, type)) {as(obj, type)} else obj
}


setClass("SWIGArray", representation(dims = "integer"), contains = "ExternalReference")

setMethod("length", "SWIGArray", function(x) x@dims[1])


defineEnumeration("SCopyReferences",
                   .values = c( "FALSE" = 0, "TRUE" = 1, "DEEP" = 2))

assert = 
function(condition, message = "")
{
  if(!condition)
    stop(message)

  TRUE
}


if(FALSE) {
print.SWIGFunction =
function(x, ...)
 {
 }
}


#######################################################################

R_SWIG_getCallbackFunctionStack =
function()
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_debug_getCallbackFunctionData")
}

R_SWIG_addCallbackFunctionStack =
function(fun, userData = NULL)
{
    # No PACKAGE argument as we don't know what the DLL is.
  .Call("R_SWIG_R_pushCallbackFunctionData", fun, userData)
}


#######################################################################


setClass('C++Reference', contains = 'ExternalReference')
setClass('_p_PEER__cWNode', contains = 'C++Reference')
setClass('_p_PEER__cXNode', contains = 'C++Reference')
setClass('_p_PEER__cAlphaNode', contains = 'C++Reference')
setClass('_p_PEER__cEpsNode', contains = 'C++Reference')
setClass('_p_PEER__cPhenoNode', contains = 'C++Reference')
setClass('_p_PEER__cVBFA', contains = 'C++Reference')



setMethod('[', "ExternalReference",
function(x,i,j, ..., drop=TRUE) 
if (!is.null(x$"__getitem__")) 
sapply(i, function(n) x$"__getitem__"(i=as.integer(n-1))))

setMethod('[<-' , "ExternalReference",
function(x,i,j, ..., value) 
if (!is.null(x$"__setitem__")) {
sapply(1:length(i), function(n) 
x$"__setitem__"(i=as.integer(i[n]-1), x=value[n]))
x
})

setAs('ExternalReference', 'character',
function(from) {if (!is.null(from$"__str__")) from$"__str__"()})

setMethod('print', 'ExternalReference',
function(x) {print(as(x, "character"))})

# Start of getVerbose

`getVerbose` = function(.copy = FALSE)
{
  ;.Call('R_swig_getVerbose', as.logical(.copy), PACKAGE='peer');
  
}

attr(`getVerbose`, 'returnType') = 'integer'
class(`getVerbose`) = c("SWIGFunction", class('getVerbose'))

# Start of setVerbose

`setVerbose` = function(verbose)
{
  verbose = as.integer(verbose); 
  
  if(length(verbose) > 1) {
    warning("using only the first element of verbose");
  };
  
  ;.Call('R_swig_setVerbose', verbose, PACKAGE='peer');
  
}

attr(`setVerbose`, 'returnType') = 'void'
attr(`setVerbose`, "inputTypes") = c('integer')
class(`setVerbose`) = c("SWIGFunction", class('setVerbose'))

# Start of logdet

`logdet` = function(m, .copy = FALSE)
{
  ;.Call('R_swig_logdet', m, as.logical(.copy), PACKAGE='peer');
  
}

attr(`logdet`, 'returnType') = 'numeric'
attr(`logdet`, "inputTypes") = c('_p_PMatrix')
class(`logdet`) = c("SWIGFunction", class('logdet'))

# Start of cWNode_E2S_set

`cWNode_E2S_set` = function(self, s_E2S)
{
  ;.Call('R_swig_cWNode_E2S_set', self, s_E2S, PACKAGE='peer');
  
}

attr(`cWNode_E2S_set`, 'returnType') = 'void'
attr(`cWNode_E2S_set`, "inputTypes") = c('_p_PEER__cWNode', '_p_PMatrix')
class(`cWNode_E2S_set`) = c("SWIGFunction", class('cWNode_E2S_set'))

# Start of cWNode_E2S_get

`cWNode_E2S_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cWNode_E2S_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cWNode_E2S_get`, 'returnType') = '_p_PMatrix'
attr(`cWNode_E2S_get`, "inputTypes") = c('_p_PEER__cWNode')
class(`cWNode_E2S_get`) = c("SWIGFunction", class('cWNode_E2S_get'))

# Start of cWNode_lndetcovS_set

`cWNode_lndetcovS_set` = function(self, s_lndetcovS)
{
  ;.Call('R_swig_cWNode_lndetcovS_set', self, s_lndetcovS, PACKAGE='peer');
  
}

attr(`cWNode_lndetcovS_set`, 'returnType') = 'void'
attr(`cWNode_lndetcovS_set`, "inputTypes") = c('_p_PEER__cWNode', 'numeric')
class(`cWNode_lndetcovS_set`) = c("SWIGFunction", class('cWNode_lndetcovS_set'))

# Start of cWNode_lndetcovS_get

`cWNode_lndetcovS_get` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_cWNode_lndetcovS_get', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cWNode_lndetcovS_get`, 'returnType') = 'numeric'
attr(`cWNode_lndetcovS_get`, "inputTypes") = c('_p_PEER__cWNode')
class(`cWNode_lndetcovS_get`) = c("SWIGFunction", class('cWNode_lndetcovS_get'))

# Start of new_cWNode

`cWNode__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cWNode__SWIG_0', PACKAGE='peer');
  class(ans) <- "_p_PEER__cWNode";
  
  reg.finalizer(ans, delete_cWNode)
  ans
  
}

attr(`cWNode__SWIG_0`, 'returnType') = '_p_PEER__cWNode'
class(`cWNode__SWIG_0`) = c("SWIGFunction", class('cWNode__SWIG_0'))

# Start of new_cWNode

`cWNode__SWIG_1` = function(E1)
{
  ;ans = .Call('R_swig_new_cWNode__SWIG_1', E1, PACKAGE='peer');
  class(ans) <- "_p_PEER__cWNode";
  
  reg.finalizer(ans, delete_cWNode)
  ans
  
}

attr(`cWNode__SWIG_1`, 'returnType') = '_p_PEER__cWNode'
attr(`cWNode__SWIG_1`, "inputTypes") = c('_p_PMatrix')
class(`cWNode__SWIG_1`) = c("SWIGFunction", class('cWNode__SWIG_1'))

`cWNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- cWNode__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_PMatrix')) {
      f <- cWNode__SWIG_1; 
    }
  };
  f(...);
}

# Dispatch function
# Start of cWNode_update

`cWNode_update` = function(self, net)
{
  ;.Call('R_swig_cWNode_update', self, net, PACKAGE='peer');
  
}

attr(`cWNode_update`, 'returnType') = 'void'
attr(`cWNode_update`, "inputTypes") = c('_p_PEER__cWNode', '_p_cBayesNet')
class(`cWNode_update`) = c("SWIGFunction", class('cWNode_update'))

# Start of cWNode_calcBound

`cWNode_calcBound` = function(self, net, .copy = FALSE)
{
  ;.Call('R_swig_cWNode_calcBound', self, net, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cWNode_calcBound`, 'returnType') = 'numeric'
attr(`cWNode_calcBound`, "inputTypes") = c('_p_PEER__cWNode', '_p_cBayesNet')
class(`cWNode_calcBound`) = c("SWIGFunction", class('cWNode_calcBound'))

# Start of cWNode_entropy

`cWNode_entropy` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_cWNode_entropy', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cWNode_entropy`, 'returnType') = 'numeric'
attr(`cWNode_entropy`, "inputTypes") = c('_p_PEER__cWNode')
class(`cWNode_entropy`) = c("SWIGFunction", class('cWNode_entropy'))

# Start of cWNode_getE1

`cWNode_getE1` = function(self)
{
  ;.Call('R_swig_cWNode_getE1', self, PACKAGE='peer');
  
}

attr(`cWNode_getE1`, 'returnType') = 'void'
attr(`cWNode_getE1`, "inputTypes") = c('_p_PEER__cWNode')
class(`cWNode_getE1`) = c("SWIGFunction", class('cWNode_getE1'))

# Start of delete_cWNode

`delete_cWNode` = function(self)
{
  ;.Call('R_swig_delete_cWNode', self, PACKAGE='peer');
  
}

attr(`delete_cWNode`, 'returnType') = 'void'
attr(`delete_cWNode`, "inputTypes") = c('_p_PEER__cWNode')
class(`delete_cWNode`) = c("SWIGFunction", class('delete_cWNode'))

# Start of accessor method for PEER::cWNode
setMethod('$', '_p_PEER__cWNode', function(x, name)

{
  accessorFuns = list('E2S' = cWNode_E2S_get, 'lndetcovS' = cWNode_lndetcovS_get, 'update' = cWNode_update, 'calcBound' = cWNode_calcBound, 'entropy' = cWNode_entropy, 'getE1' = cWNode_getE1);
  vaccessors = c('E2S', 'lndetcovS');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for PEER::cWNode
# Start of accessor method for PEER::cWNode
setMethod('$<-', '_p_PEER__cWNode', function(x, name, value)

{
  accessorFuns = list('E2S' = cWNode_E2S_set, 'lndetcovS' = cWNode_lndetcovS_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PEER__cWNode', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('E2S' = cWNode_E2S_set, 'lndetcovS' = cWNode_lndetcovS_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for PEER::cWNode
setMethod('delete', '_p_PEER__cWNode', function(obj) {delete_PEER__cWNode(obj)})
# Start of cXNode_E2S_set

`cXNode_E2S_set` = function(self, s_E2S)
{
  ;.Call('R_swig_cXNode_E2S_set', self, s_E2S, PACKAGE='peer');
  
}

attr(`cXNode_E2S_set`, 'returnType') = 'void'
attr(`cXNode_E2S_set`, "inputTypes") = c('_p_PEER__cXNode', '_p_PMatrix')
class(`cXNode_E2S_set`) = c("SWIGFunction", class('cXNode_E2S_set'))

# Start of cXNode_E2S_get

`cXNode_E2S_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cXNode_E2S_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cXNode_E2S_get`, 'returnType') = '_p_PMatrix'
attr(`cXNode_E2S_get`, "inputTypes") = c('_p_PEER__cXNode')
class(`cXNode_E2S_get`) = c("SWIGFunction", class('cXNode_E2S_get'))

# Start of cXNode_cov_set

`cXNode_cov_set` = function(self, s_cov)
{
  ;.Call('R_swig_cXNode_cov_set', self, s_cov, PACKAGE='peer');
  
}

attr(`cXNode_cov_set`, 'returnType') = 'void'
attr(`cXNode_cov_set`, "inputTypes") = c('_p_PEER__cXNode', '_p_PMatrix')
class(`cXNode_cov_set`) = c("SWIGFunction", class('cXNode_cov_set'))

# Start of cXNode_cov_get

`cXNode_cov_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cXNode_cov_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cXNode_cov_get`, 'returnType') = '_p_PMatrix'
attr(`cXNode_cov_get`, "inputTypes") = c('_p_PEER__cXNode')
class(`cXNode_cov_get`) = c("SWIGFunction", class('cXNode_cov_get'))

# Start of cXNode_prior_offset_set

`cXNode_prior_offset_set` = function(self, s_prior_offset)
{
  ;.Call('R_swig_cXNode_prior_offset_set', self, s_prior_offset, PACKAGE='peer');
  
}

attr(`cXNode_prior_offset_set`, 'returnType') = 'void'
attr(`cXNode_prior_offset_set`, "inputTypes") = c('_p_PEER__cXNode', '_p_PMatrix')
class(`cXNode_prior_offset_set`) = c("SWIGFunction", class('cXNode_prior_offset_set'))

# Start of cXNode_prior_offset_get

`cXNode_prior_offset_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cXNode_prior_offset_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cXNode_prior_offset_get`, 'returnType') = '_p_PMatrix'
attr(`cXNode_prior_offset_get`, "inputTypes") = c('_p_PEER__cXNode')
class(`cXNode_prior_offset_get`) = c("SWIGFunction", class('cXNode_prior_offset_get'))

# Start of cXNode_prior_prec_set

`cXNode_prior_prec_set` = function(self, s_prior_prec)
{
  ;.Call('R_swig_cXNode_prior_prec_set', self, s_prior_prec, PACKAGE='peer');
  
}

attr(`cXNode_prior_prec_set`, 'returnType') = 'void'
attr(`cXNode_prior_prec_set`, "inputTypes") = c('_p_PEER__cXNode', '_p_PMatrix')
class(`cXNode_prior_prec_set`) = c("SWIGFunction", class('cXNode_prior_prec_set'))

# Start of cXNode_prior_prec_get

`cXNode_prior_prec_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cXNode_prior_prec_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cXNode_prior_prec_get`, 'returnType') = '_p_PMatrix'
attr(`cXNode_prior_prec_get`, "inputTypes") = c('_p_PEER__cXNode')
class(`cXNode_prior_prec_get`) = c("SWIGFunction", class('cXNode_prior_prec_get'))

# Start of new_cXNode

`cXNode__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cXNode__SWIG_0', PACKAGE='peer');
  class(ans) <- "_p_PEER__cXNode";
  
  reg.finalizer(ans, delete_cXNode)
  ans
  
}

attr(`cXNode__SWIG_0`, 'returnType') = '_p_PEER__cXNode'
class(`cXNode__SWIG_0`) = c("SWIGFunction", class('cXNode__SWIG_0'))

# Start of new_cXNode

`cXNode__SWIG_1` = function(E1)
{
  ;ans = .Call('R_swig_new_cXNode__SWIG_1', E1, PACKAGE='peer');
  class(ans) <- "_p_PEER__cXNode";
  
  reg.finalizer(ans, delete_cXNode)
  ans
  
}

attr(`cXNode__SWIG_1`, 'returnType') = '_p_PEER__cXNode'
attr(`cXNode__SWIG_1`, "inputTypes") = c('_p_PMatrix')
class(`cXNode__SWIG_1`) = c("SWIGFunction", class('cXNode__SWIG_1'))

# Start of new_cXNode

`cXNode__SWIG_2` = function(E1, prior_offset, prior_prec)
{
  ;ans = .Call('R_swig_new_cXNode__SWIG_2', E1, prior_offset, prior_prec, PACKAGE='peer');
  class(ans) <- "_p_PEER__cXNode";
  
  reg.finalizer(ans, delete_cXNode)
  ans
  
}

attr(`cXNode__SWIG_2`, 'returnType') = '_p_PEER__cXNode'
attr(`cXNode__SWIG_2`, "inputTypes") = c('_p_PMatrix', '_p_PMatrix', '_p_PMatrix')
class(`cXNode__SWIG_2`) = c("SWIGFunction", class('cXNode__SWIG_2'))

`cXNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 3
  if (argc == 0) {
    f <- cXNode__SWIG_0; 
  } else if (argc == 1) {
    if (extends(argtypes[1], '_p_PMatrix')) {
      f <- cXNode__SWIG_1; 
    }
  } else if (argc == 3) {
    if (extends(argtypes[1], '_p_PMatrix') && extends(argtypes[2], '_p_PMatrix') && extends(argtypes[3], '_p_PMatrix')) {
      f <- cXNode__SWIG_2; 
    }
  };
  f(...);
}

# Dispatch function
# Start of cXNode_update

`cXNode_update` = function(self, net)
{
  ;.Call('R_swig_cXNode_update', self, net, PACKAGE='peer');
  
}

attr(`cXNode_update`, 'returnType') = 'void'
attr(`cXNode_update`, "inputTypes") = c('_p_PEER__cXNode', '_p_cBayesNet')
class(`cXNode_update`) = c("SWIGFunction", class('cXNode_update'))

# Start of cXNode_calcBound

`cXNode_calcBound` = function(self, net, .copy = FALSE)
{
  ;.Call('R_swig_cXNode_calcBound', self, net, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cXNode_calcBound`, 'returnType') = 'numeric'
attr(`cXNode_calcBound`, "inputTypes") = c('_p_PEER__cXNode', '_p_cBayesNet')
class(`cXNode_calcBound`) = c("SWIGFunction", class('cXNode_calcBound'))

# Start of cXNode_entropy

`cXNode_entropy` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_cXNode_entropy', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`cXNode_entropy`, 'returnType') = 'numeric'
attr(`cXNode_entropy`, "inputTypes") = c('_p_PEER__cXNode')
class(`cXNode_entropy`) = c("SWIGFunction", class('cXNode_entropy'))

# Start of cXNode_getE1

`cXNode_getE1` = function(self)
{
  ;.Call('R_swig_cXNode_getE1', self, PACKAGE='peer');
  
}

attr(`cXNode_getE1`, 'returnType') = 'void'
attr(`cXNode_getE1`, "inputTypes") = c('_p_PEER__cXNode')
class(`cXNode_getE1`) = c("SWIGFunction", class('cXNode_getE1'))

# Start of delete_cXNode

`delete_cXNode` = function(self)
{
  ;.Call('R_swig_delete_cXNode', self, PACKAGE='peer');
  
}

attr(`delete_cXNode`, 'returnType') = 'void'
attr(`delete_cXNode`, "inputTypes") = c('_p_PEER__cXNode')
class(`delete_cXNode`) = c("SWIGFunction", class('delete_cXNode'))

# Start of accessor method for PEER::cXNode
setMethod('$', '_p_PEER__cXNode', function(x, name)

{
  accessorFuns = list('E2S' = cXNode_E2S_get, 'cov' = cXNode_cov_get, 'prior_offset' = cXNode_prior_offset_get, 'prior_prec' = cXNode_prior_prec_get, 'update' = cXNode_update, 'calcBound' = cXNode_calcBound, 'entropy' = cXNode_entropy, 'getE1' = cXNode_getE1);
  vaccessors = c('E2S', 'cov', 'prior_offset', 'prior_prec');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for PEER::cXNode
# Start of accessor method for PEER::cXNode
setMethod('$<-', '_p_PEER__cXNode', function(x, name, value)

{
  accessorFuns = list('E2S' = cXNode_E2S_set, 'cov' = cXNode_cov_set, 'prior_offset' = cXNode_prior_offset_set, 'prior_prec' = cXNode_prior_prec_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PEER__cXNode', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('E2S' = cXNode_E2S_set, 'cov' = cXNode_cov_set, 'prior_offset' = cXNode_prior_offset_set, 'prior_prec' = cXNode_prior_prec_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for PEER::cXNode
setMethod('delete', '_p_PEER__cXNode', function(obj) {delete_PEER__cXNode(obj)})
# Start of new_cAlphaNode

`cAlphaNode__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cAlphaNode__SWIG_0', PACKAGE='peer');
  class(ans) <- "_p_PEER__cAlphaNode";
  
  reg.finalizer(ans, delete_cAlphaNode)
  ans
  
}

attr(`cAlphaNode__SWIG_0`, 'returnType') = '_p_PEER__cAlphaNode'
class(`cAlphaNode__SWIG_0`) = c("SWIGFunction", class('cAlphaNode__SWIG_0'))

# Start of new_cAlphaNode

`cAlphaNode__SWIG_1` = function(dim, pa, pb, E1)
{
  dim = as.integer(dim); 
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_cAlphaNode__SWIG_1', dim, pa, pb, E1, PACKAGE='peer');
  class(ans) <- "_p_PEER__cAlphaNode";
  
  reg.finalizer(ans, delete_cAlphaNode)
  ans
  
}

attr(`cAlphaNode__SWIG_1`, 'returnType') = '_p_PEER__cAlphaNode'
attr(`cAlphaNode__SWIG_1`, "inputTypes") = c('integer', 'numeric', 'numeric', '_p_PMatrix')
class(`cAlphaNode__SWIG_1`) = c("SWIGFunction", class('cAlphaNode__SWIG_1'))

`cAlphaNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- cAlphaNode__SWIG_0; 
  } else if (argc == 4) {
    if (extends(argtypes[1], 'integer') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_PMatrix')) {
      f <- cAlphaNode__SWIG_1; 
    }
  };
  f(...);
}

# Dispatch function
# Start of cAlphaNode_update

`cAlphaNode_update` = function(self, net)
{
  ;.Call('R_swig_cAlphaNode_update', self, net, PACKAGE='peer');
  
}

attr(`cAlphaNode_update`, 'returnType') = 'void'
attr(`cAlphaNode_update`, "inputTypes") = c('_p_PEER__cAlphaNode', '_p_cBayesNet')
class(`cAlphaNode_update`) = c("SWIGFunction", class('cAlphaNode_update'))

# Start of cAlphaNode_getE1

`cAlphaNode_getE1` = function(self)
{
  ;.Call('R_swig_cAlphaNode_getE1', self, PACKAGE='peer');
  
}

attr(`cAlphaNode_getE1`, 'returnType') = 'void'
attr(`cAlphaNode_getE1`, "inputTypes") = c('_p_PEER__cAlphaNode')
class(`cAlphaNode_getE1`) = c("SWIGFunction", class('cAlphaNode_getE1'))

# Start of delete_cAlphaNode

`delete_cAlphaNode` = function(self)
{
  ;.Call('R_swig_delete_cAlphaNode', self, PACKAGE='peer');
  
}

attr(`delete_cAlphaNode`, 'returnType') = 'void'
attr(`delete_cAlphaNode`, "inputTypes") = c('_p_PEER__cAlphaNode')
class(`delete_cAlphaNode`) = c("SWIGFunction", class('delete_cAlphaNode'))

# Start of accessor method for PEER::cAlphaNode
setMethod('$', '_p_PEER__cAlphaNode', function(x, name)

{
  accessorFuns = list('update' = cAlphaNode_update, 'getE1' = cAlphaNode_getE1);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PEER::cAlphaNode
setMethod('delete', '_p_PEER__cAlphaNode', function(obj) {delete_PEER__cAlphaNode(obj)})
# Start of new_cEpsNode

`cEpsNode__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cEpsNode__SWIG_0', PACKAGE='peer');
  class(ans) <- "_p_PEER__cEpsNode";
  
  reg.finalizer(ans, delete_cEpsNode)
  ans
  
}

attr(`cEpsNode__SWIG_0`, 'returnType') = '_p_PEER__cEpsNode'
class(`cEpsNode__SWIG_0`) = c("SWIGFunction", class('cEpsNode__SWIG_0'))

# Start of new_cEpsNode

`cEpsNode__SWIG_1` = function(dim, pa, pb, E1)
{
  dim = as.integer(dim); 
  
  if(length(dim) > 1) {
    warning("using only the first element of dim");
  };
  
  
  
  
  ;ans = .Call('R_swig_new_cEpsNode__SWIG_1', dim, pa, pb, E1, PACKAGE='peer');
  class(ans) <- "_p_PEER__cEpsNode";
  
  reg.finalizer(ans, delete_cEpsNode)
  ans
  
}

attr(`cEpsNode__SWIG_1`, 'returnType') = '_p_PEER__cEpsNode'
attr(`cEpsNode__SWIG_1`, "inputTypes") = c('integer', 'numeric', 'numeric', '_p_PMatrix')
class(`cEpsNode__SWIG_1`) = c("SWIGFunction", class('cEpsNode__SWIG_1'))

`cEpsNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- cEpsNode__SWIG_0; 
  } else if (argc == 4) {
    if (extends(argtypes[1], 'integer') && is.numeric(argv[[2]]) && is.numeric(argv[[3]]) && extends(argtypes[4], '_p_PMatrix')) {
      f <- cEpsNode__SWIG_1; 
    }
  };
  f(...);
}

# Dispatch function
# Start of cEpsNode_update

`cEpsNode_update` = function(self, net)
{
  ;.Call('R_swig_cEpsNode_update', self, net, PACKAGE='peer');
  
}

attr(`cEpsNode_update`, 'returnType') = 'void'
attr(`cEpsNode_update`, "inputTypes") = c('_p_PEER__cEpsNode', '_p_cBayesNet')
class(`cEpsNode_update`) = c("SWIGFunction", class('cEpsNode_update'))

# Start of cEpsNode_getE1

`cEpsNode_getE1` = function(self)
{
  ;.Call('R_swig_cEpsNode_getE1', self, PACKAGE='peer');
  
}

attr(`cEpsNode_getE1`, 'returnType') = 'void'
attr(`cEpsNode_getE1`, "inputTypes") = c('_p_PEER__cEpsNode')
class(`cEpsNode_getE1`) = c("SWIGFunction", class('cEpsNode_getE1'))

# Start of delete_cEpsNode

`delete_cEpsNode` = function(self)
{
  ;.Call('R_swig_delete_cEpsNode', self, PACKAGE='peer');
  
}

attr(`delete_cEpsNode`, 'returnType') = 'void'
attr(`delete_cEpsNode`, "inputTypes") = c('_p_PEER__cEpsNode')
class(`delete_cEpsNode`) = c("SWIGFunction", class('delete_cEpsNode'))

# Start of accessor method for PEER::cEpsNode
setMethod('$', '_p_PEER__cEpsNode', function(x, name)

{
  accessorFuns = list('update' = cEpsNode_update, 'getE1' = cEpsNode_getE1);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  f;
}


);
# end of accessor method for PEER::cEpsNode
setMethod('delete', '_p_PEER__cEpsNode', function(obj) {delete_PEER__cEpsNode(obj)})
# Start of cPhenoNode_E1_set

`cPhenoNode_E1_set` = function(self, s_E1)
{
  ;.Call('R_swig_cPhenoNode_E1_set', self, s_E1, PACKAGE='peer');
  
}

attr(`cPhenoNode_E1_set`, 'returnType') = 'void'
attr(`cPhenoNode_E1_set`, "inputTypes") = c('_p_PEER__cPhenoNode', '_p_PMatrix')
class(`cPhenoNode_E1_set`) = c("SWIGFunction", class('cPhenoNode_E1_set'))

# Start of cPhenoNode_E1_get

`cPhenoNode_E1_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cPhenoNode_E1_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cPhenoNode_E1_get`, 'returnType') = '_p_PMatrix'
attr(`cPhenoNode_E1_get`, "inputTypes") = c('_p_PEER__cPhenoNode')
class(`cPhenoNode_E1_get`) = c("SWIGFunction", class('cPhenoNode_E1_get'))

# Start of cPhenoNode_E2_set

`cPhenoNode_E2_set` = function(self, s_E2)
{
  ;.Call('R_swig_cPhenoNode_E2_set', self, s_E2, PACKAGE='peer');
  
}

attr(`cPhenoNode_E2_set`, 'returnType') = 'void'
attr(`cPhenoNode_E2_set`, "inputTypes") = c('_p_PEER__cPhenoNode', '_p_PMatrix')
class(`cPhenoNode_E2_set`) = c("SWIGFunction", class('cPhenoNode_E2_set'))

# Start of cPhenoNode_E2_get

`cPhenoNode_E2_get` = function(self, .copy = FALSE)
{
  ;ans = .Call('R_swig_cPhenoNode_E2_get', self, as.logical(.copy), PACKAGE='peer');
  class(ans) <- "_p_PMatrix";
  
  ans
  
}

attr(`cPhenoNode_E2_get`, 'returnType') = '_p_PMatrix'
attr(`cPhenoNode_E2_get`, "inputTypes") = c('_p_PEER__cPhenoNode')
class(`cPhenoNode_E2_get`) = c("SWIGFunction", class('cPhenoNode_E2_get'))

# Start of new_cPhenoNode

`cPhenoNode__SWIG_0` = function()
{
  ;ans = .Call('R_swig_new_cPhenoNode__SWIG_0', PACKAGE='peer');
  class(ans) <- "_p_PEER__cPhenoNode";
  
  reg.finalizer(ans, delete_cPhenoNode)
  ans
  
}

attr(`cPhenoNode__SWIG_0`, 'returnType') = '_p_PEER__cPhenoNode'
class(`cPhenoNode__SWIG_0`) = c("SWIGFunction", class('cPhenoNode__SWIG_0'))

# Start of new_cPhenoNode

`cPhenoNode__SWIG_1` = function(pheno_mean, pheno_var)
{
  ;ans = .Call('R_swig_new_cPhenoNode__SWIG_1', pheno_mean, pheno_var, PACKAGE='peer');
  class(ans) <- "_p_PEER__cPhenoNode";
  
  reg.finalizer(ans, delete_cPhenoNode)
  ans
  
}

attr(`cPhenoNode__SWIG_1`, 'returnType') = '_p_PEER__cPhenoNode'
attr(`cPhenoNode__SWIG_1`, "inputTypes") = c('_p_PMatrix', '_p_PMatrix')
class(`cPhenoNode__SWIG_1`) = c("SWIGFunction", class('cPhenoNode__SWIG_1'))

`cPhenoNode` <- function(...) {
  argtypes <- mapply(class, list(...));
  argv <- list(...);
  argc <- length(argtypes);
# dispatch functions 2
  if (argc == 0) {
    f <- cPhenoNode__SWIG_0; 
  } else if (argc == 2) {
    if (extends(argtypes[1], '_p_PMatrix') && extends(argtypes[2], '_p_PMatrix')) {
      f <- cPhenoNode__SWIG_1; 
    }
  };
  f(...);
}

# Dispatch function
# Start of cPhenoNode_getE1

`cPhenoNode_getE1` = function(self)
{
  ;.Call('R_swig_cPhenoNode_getE1', self, PACKAGE='peer');
  
}

attr(`cPhenoNode_getE1`, 'returnType') = 'void'
attr(`cPhenoNode_getE1`, "inputTypes") = c('_p_PEER__cPhenoNode')
class(`cPhenoNode_getE1`) = c("SWIGFunction", class('cPhenoNode_getE1'))

# Start of delete_cPhenoNode

`delete_cPhenoNode` = function(self)
{
  ;.Call('R_swig_delete_cPhenoNode', self, PACKAGE='peer');
  
}

attr(`delete_cPhenoNode`, 'returnType') = 'void'
attr(`delete_cPhenoNode`, "inputTypes") = c('_p_PEER__cPhenoNode')
class(`delete_cPhenoNode`) = c("SWIGFunction", class('delete_cPhenoNode'))

# Start of accessor method for PEER::cPhenoNode
setMethod('$', '_p_PEER__cPhenoNode', function(x, name)

{
  accessorFuns = list('E1' = cPhenoNode_E1_get, 'E2' = cPhenoNode_E2_get, 'getE1' = cPhenoNode_getE1);
  vaccessors = c('E1', 'E2');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for PEER::cPhenoNode
# Start of accessor method for PEER::cPhenoNode
setMethod('$<-', '_p_PEER__cPhenoNode', function(x, name, value)

{
  accessorFuns = list('E1' = cPhenoNode_E1_set, 'E2' = cPhenoNode_E2_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PEER__cPhenoNode', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('E1' = cPhenoNode_E1_set, 'E2' = cPhenoNode_E2_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for PEER::cPhenoNode
setMethod('delete', '_p_PEER__cPhenoNode', function(obj) {delete_PEER__cPhenoNode(obj)})
defineEnumeration('_PEER__intialisation_types',
                    .values = c(
                        'PCA' = 0
))
# Start of VBFA_W_set

`VBFA_W_set` = function(self, s_W)
{
  ;.Call('R_swig_VBFA_W_set', self, s_W, PACKAGE='peer');
  
}

attr(`VBFA_W_set`, 'returnType') = 'void'
attr(`VBFA_W_set`, "inputTypes") = c('_p_PEER__cVBFA', '_p_PEER__cWNode')
class(`VBFA_W_set`) = c("SWIGFunction", class('VBFA_W_set'))

# Start of VBFA_W_get

`VBFA_W_get` = function(self)
{
  ;ans = .Call('R_swig_VBFA_W_get', self, PACKAGE='peer');
  class(ans) <- "_p_PEER__cWNode";
  
  ans
  
}

attr(`VBFA_W_get`, 'returnType') = '_p_PEER__cWNode'
attr(`VBFA_W_get`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_W_get`) = c("SWIGFunction", class('VBFA_W_get'))

# Start of VBFA_X_set

`VBFA_X_set` = function(self, s_X)
{
  ;.Call('R_swig_VBFA_X_set', self, s_X, PACKAGE='peer');
  
}

attr(`VBFA_X_set`, 'returnType') = 'void'
attr(`VBFA_X_set`, "inputTypes") = c('_p_PEER__cVBFA', '_p_PEER__cXNode')
class(`VBFA_X_set`) = c("SWIGFunction", class('VBFA_X_set'))

# Start of VBFA_X_get

`VBFA_X_get` = function(self)
{
  ;ans = .Call('R_swig_VBFA_X_get', self, PACKAGE='peer');
  class(ans) <- "_p_PEER__cXNode";
  
  ans
  
}

attr(`VBFA_X_get`, 'returnType') = '_p_PEER__cXNode'
attr(`VBFA_X_get`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_X_get`) = c("SWIGFunction", class('VBFA_X_get'))

# Start of VBFA_Eps_set

`VBFA_Eps_set` = function(self, s_Eps)
{
  ;.Call('R_swig_VBFA_Eps_set', self, s_Eps, PACKAGE='peer');
  
}

attr(`VBFA_Eps_set`, 'returnType') = 'void'
attr(`VBFA_Eps_set`, "inputTypes") = c('_p_PEER__cVBFA', '_p_PEER__cEpsNode')
class(`VBFA_Eps_set`) = c("SWIGFunction", class('VBFA_Eps_set'))

# Start of VBFA_Eps_get

`VBFA_Eps_get` = function(self)
{
  ;ans = .Call('R_swig_VBFA_Eps_get', self, PACKAGE='peer');
  class(ans) <- "_p_PEER__cEpsNode";
  
  ans
  
}

attr(`VBFA_Eps_get`, 'returnType') = '_p_PEER__cEpsNode'
attr(`VBFA_Eps_get`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_Eps_get`) = c("SWIGFunction", class('VBFA_Eps_get'))

# Start of VBFA_Alpha_set

`VBFA_Alpha_set` = function(self, s_Alpha)
{
  ;.Call('R_swig_VBFA_Alpha_set', self, s_Alpha, PACKAGE='peer');
  
}

attr(`VBFA_Alpha_set`, 'returnType') = 'void'
attr(`VBFA_Alpha_set`, "inputTypes") = c('_p_PEER__cVBFA', '_p_PEER__cAlphaNode')
class(`VBFA_Alpha_set`) = c("SWIGFunction", class('VBFA_Alpha_set'))

# Start of VBFA_Alpha_get

`VBFA_Alpha_get` = function(self)
{
  ;ans = .Call('R_swig_VBFA_Alpha_get', self, PACKAGE='peer');
  class(ans) <- "_p_PEER__cAlphaNode";
  
  ans
  
}

attr(`VBFA_Alpha_get`, 'returnType') = '_p_PEER__cAlphaNode'
attr(`VBFA_Alpha_get`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_Alpha_get`) = c("SWIGFunction", class('VBFA_Alpha_get'))

# Start of VBFA_pheno_set

`VBFA_pheno_set` = function(self, s_pheno)
{
  ;.Call('R_swig_VBFA_pheno_set', self, s_pheno, PACKAGE='peer');
  
}

attr(`VBFA_pheno_set`, 'returnType') = 'void'
attr(`VBFA_pheno_set`, "inputTypes") = c('_p_PEER__cVBFA', '_p_PEER__cPhenoNode')
class(`VBFA_pheno_set`) = c("SWIGFunction", class('VBFA_pheno_set'))

# Start of VBFA_pheno_get

`VBFA_pheno_get` = function(self)
{
  ;ans = .Call('R_swig_VBFA_pheno_get', self, PACKAGE='peer');
  class(ans) <- "_p_PEER__cPhenoNode";
  
  ans
  
}

attr(`VBFA_pheno_get`, 'returnType') = '_p_PEER__cPhenoNode'
attr(`VBFA_pheno_get`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_pheno_get`) = c("SWIGFunction", class('VBFA_pheno_get'))

# Start of new_VBFA

`VBFA` = function()
{
  ;ans = .Call('R_swig_new_VBFA', PACKAGE='peer');
  class(ans) <- "_p_PEER__cVBFA";
  
  reg.finalizer(ans, delete_VBFA)
  ans
  
}

attr(`VBFA`, 'returnType') = '_p_PEER__cVBFA'
class(`VBFA`) = c("SWIGFunction", class('VBFA'))

# Start of VBFA_getNj

`VBFA_getNj` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getNj', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getNj`, 'returnType') = 'integer'
attr(`VBFA_getNj`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getNj`) = c("SWIGFunction", class('VBFA_getNj'))

# Start of VBFA_getNp

`VBFA_getNp` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getNp', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getNp`, 'returnType') = 'integer'
attr(`VBFA_getNp`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getNp`) = c("SWIGFunction", class('VBFA_getNp'))

# Start of VBFA_getNk

`VBFA_getNk` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getNk', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getNk`, 'returnType') = 'integer'
attr(`VBFA_getNk`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getNk`) = c("SWIGFunction", class('VBFA_getNk'))

# Start of VBFA_getNc

`VBFA_getNc` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getNc', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getNc`, 'returnType') = 'integer'
attr(`VBFA_getNc`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getNc`) = c("SWIGFunction", class('VBFA_getNc'))

# Start of VBFA_getNmax_iterations

`VBFA_getNmax_iterations` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getNmax_iterations', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getNmax_iterations`, 'returnType') = 'integer'
attr(`VBFA_getNmax_iterations`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getNmax_iterations`) = c("SWIGFunction", class('VBFA_getNmax_iterations'))

# Start of VBFA_getTolerance

`VBFA_getTolerance` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getTolerance', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getTolerance`, 'returnType') = 'numeric'
attr(`VBFA_getTolerance`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getTolerance`) = c("SWIGFunction", class('VBFA_getTolerance'))

# Start of VBFA_getAdd_mean

`VBFA_getAdd_mean` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_getAdd_mean', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_getAdd_mean`, 'returnType') = 'logical'
attr(`VBFA_getAdd_mean`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getAdd_mean`) = c("SWIGFunction", class('VBFA_getAdd_mean'))

# Start of VBFA_setNk

`VBFA_setNk` = function(self, Nk)
{
  Nk = as.integer(Nk); 
  
  if(length(Nk) > 1) {
    warning("using only the first element of Nk");
  };
  
  ;.Call('R_swig_VBFA_setNk', self, Nk, PACKAGE='peer');
  
}

attr(`VBFA_setNk`, 'returnType') = 'void'
attr(`VBFA_setNk`, "inputTypes") = c('_p_PEER__cVBFA', 'integer')
class(`VBFA_setNk`) = c("SWIGFunction", class('VBFA_setNk'))

# Start of VBFA_setAdd_mean

`VBFA_setAdd_mean` = function(self, add_mean)
{
  add_mean = as.logical(add_mean);
  ;.Call('R_swig_VBFA_setAdd_mean', self, add_mean, PACKAGE='peer');
  
}

attr(`VBFA_setAdd_mean`, 'returnType') = 'void'
attr(`VBFA_setAdd_mean`, "inputTypes") = c('_p_PEER__cVBFA', 'logical')
class(`VBFA_setAdd_mean`) = c("SWIGFunction", class('VBFA_setAdd_mean'))

# Start of VBFA_setNmax_iterations

`VBFA_setNmax_iterations` = function(self, Nmax_iterations)
{
  Nmax_iterations = as.integer(Nmax_iterations); 
  
  if(length(Nmax_iterations) > 1) {
    warning("using only the first element of Nmax_iterations");
  };
  
  ;.Call('R_swig_VBFA_setNmax_iterations', self, Nmax_iterations, PACKAGE='peer');
  
}

attr(`VBFA_setNmax_iterations`, 'returnType') = 'void'
attr(`VBFA_setNmax_iterations`, "inputTypes") = c('_p_PEER__cVBFA', 'integer')
class(`VBFA_setNmax_iterations`) = c("SWIGFunction", class('VBFA_setNmax_iterations'))

# Start of VBFA_setTolerance

`VBFA_setTolerance` = function(self, tolerance)
{
  ;.Call('R_swig_VBFA_setTolerance', self, tolerance, PACKAGE='peer');
  
}

attr(`VBFA_setTolerance`, 'returnType') = 'void'
attr(`VBFA_setTolerance`, "inputTypes") = c('_p_PEER__cVBFA', 'numeric')
class(`VBFA_setTolerance`) = c("SWIGFunction", class('VBFA_setTolerance'))

# Start of VBFA_setPriorAlpha

`VBFA_setPriorAlpha` = function(self, pa, pb)
{
  ;.Call('R_swig_VBFA_setPriorAlpha', self, pa, pb, PACKAGE='peer');
  
}

attr(`VBFA_setPriorAlpha`, 'returnType') = 'void'
attr(`VBFA_setPriorAlpha`, "inputTypes") = c('_p_PEER__cVBFA', 'numeric', 'numeric')
class(`VBFA_setPriorAlpha`) = c("SWIGFunction", class('VBFA_setPriorAlpha'))

# Start of VBFA_setPriorEps

`VBFA_setPriorEps` = function(self, pa, pb)
{
  ;.Call('R_swig_VBFA_setPriorEps', self, pa, pb, PACKAGE='peer');
  
}

attr(`VBFA_setPriorEps`, 'returnType') = 'void'
attr(`VBFA_setPriorEps`, "inputTypes") = c('_p_PEER__cVBFA', 'numeric', 'numeric')
class(`VBFA_setPriorEps`) = c("SWIGFunction", class('VBFA_setPriorEps'))

# Start of VBFA_init_net

`VBFA_init_net` = function(self)
{
  ;.Call('R_swig_VBFA_init_net', self, PACKAGE='peer');
  
}

attr(`VBFA_init_net`, 'returnType') = 'void'
attr(`VBFA_init_net`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_init_net`) = c("SWIGFunction", class('VBFA_init_net'))

# Start of VBFA_calcBound

`VBFA_calcBound` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_calcBound', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_calcBound`, 'returnType') = 'numeric'
attr(`VBFA_calcBound`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_calcBound`) = c("SWIGFunction", class('VBFA_calcBound'))

# Start of VBFA_logprob

`VBFA_logprob` = function(self, .copy = FALSE)
{
  ;.Call('R_swig_VBFA_logprob', self, as.logical(.copy), PACKAGE='peer');
  
}

attr(`VBFA_logprob`, 'returnType') = 'numeric'
attr(`VBFA_logprob`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_logprob`) = c("SWIGFunction", class('VBFA_logprob'))

# Start of VBFA_update

`VBFA_update` = function(self)
{
  ;.Call('R_swig_VBFA_update', self, PACKAGE='peer');
  
}

attr(`VBFA_update`, 'returnType') = 'void'
attr(`VBFA_update`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_update`) = c("SWIGFunction", class('VBFA_update'))

# Start of VBFA_setPhenoMean

`VBFA_setPhenoMean` = function(self, matrix)
{
  ;.Call('R_swig_VBFA_setPhenoMean', self, matrix, PACKAGE='peer');
  
}

attr(`VBFA_setPhenoMean`, 'returnType') = 'void'
attr(`VBFA_setPhenoMean`, "inputTypes") = c('_p_PEER__cVBFA', '_p_float64_t')
class(`VBFA_setPhenoMean`) = c("SWIGFunction", class('VBFA_setPhenoMean'))

# Start of VBFA_setPhenoVar

`VBFA_setPhenoVar` = function(self, matrix)
{
  ;.Call('R_swig_VBFA_setPhenoVar', self, matrix, PACKAGE='peer');
  
}

attr(`VBFA_setPhenoVar`, 'returnType') = 'void'
attr(`VBFA_setPhenoVar`, "inputTypes") = c('_p_PEER__cVBFA', '_p_float64_t')
class(`VBFA_setPhenoVar`) = c("SWIGFunction", class('VBFA_setPhenoVar'))

# Start of VBFA_setCovariates

`VBFA_setCovariates` = function(self, matrix)
{
  ;.Call('R_swig_VBFA_setCovariates', self, matrix, PACKAGE='peer');
  
}

attr(`VBFA_setCovariates`, 'returnType') = 'void'
attr(`VBFA_setCovariates`, "inputTypes") = c('_p_PEER__cVBFA', '_p_float64_t')
class(`VBFA_setCovariates`) = c("SWIGFunction", class('VBFA_setCovariates'))

# Start of VBFA_getPhenoMean

`VBFA_getPhenoMean` = function(self)
{
  ;.Call('R_swig_VBFA_getPhenoMean', self, PACKAGE='peer');
  
}

attr(`VBFA_getPhenoMean`, 'returnType') = 'void'
attr(`VBFA_getPhenoMean`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getPhenoMean`) = c("SWIGFunction", class('VBFA_getPhenoMean'))

# Start of VBFA_getPhenoVar

`VBFA_getPhenoVar` = function(self)
{
  ;.Call('R_swig_VBFA_getPhenoVar', self, PACKAGE='peer');
  
}

attr(`VBFA_getPhenoVar`, 'returnType') = 'void'
attr(`VBFA_getPhenoVar`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getPhenoVar`) = c("SWIGFunction", class('VBFA_getPhenoVar'))

# Start of VBFA_getCovariates

`VBFA_getCovariates` = function(self)
{
  ;.Call('R_swig_VBFA_getCovariates', self, PACKAGE='peer');
  
}

attr(`VBFA_getCovariates`, 'returnType') = 'void'
attr(`VBFA_getCovariates`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getCovariates`) = c("SWIGFunction", class('VBFA_getCovariates'))

# Start of VBFA_getX

`VBFA_getX` = function(self)
{
  ;.Call('R_swig_VBFA_getX', self, PACKAGE='peer');
  
}

attr(`VBFA_getX`, 'returnType') = 'void'
attr(`VBFA_getX`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getX`) = c("SWIGFunction", class('VBFA_getX'))

# Start of VBFA_getW

`VBFA_getW` = function(self)
{
  ;.Call('R_swig_VBFA_getW', self, PACKAGE='peer');
  
}

attr(`VBFA_getW`, 'returnType') = 'void'
attr(`VBFA_getW`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getW`) = c("SWIGFunction", class('VBFA_getW'))

# Start of VBFA_getEps

`VBFA_getEps` = function(self)
{
  ;.Call('R_swig_VBFA_getEps', self, PACKAGE='peer');
  
}

attr(`VBFA_getEps`, 'returnType') = 'void'
attr(`VBFA_getEps`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getEps`) = c("SWIGFunction", class('VBFA_getEps'))

# Start of VBFA_getAlpha

`VBFA_getAlpha` = function(self)
{
  ;.Call('R_swig_VBFA_getAlpha', self, PACKAGE='peer');
  
}

attr(`VBFA_getAlpha`, 'returnType') = 'void'
attr(`VBFA_getAlpha`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getAlpha`) = c("SWIGFunction", class('VBFA_getAlpha'))

# Start of VBFA_getResiduals

`VBFA_getResiduals` = function(self)
{
  ;.Call('R_swig_VBFA_getResiduals', self, PACKAGE='peer');
  
}

attr(`VBFA_getResiduals`, 'returnType') = 'void'
attr(`VBFA_getResiduals`, "inputTypes") = c('_p_PEER__cVBFA')
class(`VBFA_getResiduals`) = c("SWIGFunction", class('VBFA_getResiduals'))

# Start of delete_VBFA

`delete_VBFA` = function(self)
{
  ;.Call('R_swig_delete_VBFA', self, PACKAGE='peer');
  
}

attr(`delete_VBFA`, 'returnType') = 'void'
attr(`delete_VBFA`, "inputTypes") = c('_p_PEER__cVBFA')
class(`delete_VBFA`) = c("SWIGFunction", class('delete_VBFA'))

# Start of accessor method for PEER::cVBFA
setMethod('$', '_p_PEER__cVBFA', function(x, name)

{
  accessorFuns = list('W' = VBFA_W_get, 'X' = VBFA_X_get, 'Eps' = VBFA_Eps_get, 'Alpha' = VBFA_Alpha_get, 'pheno' = VBFA_pheno_get, 'getNj' = VBFA_getNj, 'getNp' = VBFA_getNp, 'getNk' = VBFA_getNk, 'getNc' = VBFA_getNc, 'getNmax_iterations' = VBFA_getNmax_iterations, 'getTolerance' = VBFA_getTolerance, 'getAdd_mean' = VBFA_getAdd_mean, 'setNk' = VBFA_setNk, 'setAdd_mean' = VBFA_setAdd_mean, 'setNmax_iterations' = VBFA_setNmax_iterations, 'setTolerance' = VBFA_setTolerance, 'setPriorAlpha' = VBFA_setPriorAlpha, 'setPriorEps' = VBFA_setPriorEps, 'init_net' = VBFA_init_net, 'calcBound' = VBFA_calcBound, 'logprob' = VBFA_logprob, 'update' = VBFA_update, 'setPhenoMean' = VBFA_setPhenoMean, 'setPhenoVar' = VBFA_setPhenoVar, 'setCovariates' = VBFA_setCovariates, 'getPhenoMean' = VBFA_getPhenoMean, 'getPhenoVar' = VBFA_getPhenoVar, 'getCovariates' = VBFA_getCovariates, 'getX' = VBFA_getX, 'getW' = VBFA_getW, 'getEps' = VBFA_getEps, 'getAlpha' = VBFA_getAlpha, 'getResiduals' = VBFA_getResiduals);
  vaccessors = c('W', 'X', 'Eps', 'Alpha', 'pheno');
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name));
  f = accessorFuns[[idx]];
  formals(f)[[1]] = x;
  if (is.na(match(name, vaccessors))) f else f(x);
}


);
# end of accessor method for PEER::cVBFA
# Start of accessor method for PEER::cVBFA
setMethod('$<-', '_p_PEER__cVBFA', function(x, name, value)

{
  accessorFuns = list('W' = VBFA_W_set, 'X' = VBFA_X_set, 'Eps' = VBFA_Eps_set, 'Alpha' = VBFA_Alpha_set, 'pheno' = VBFA_pheno_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
setMethod('[[<-', c('_p_PEER__cVBFA', 'character'),function(x, i, j, ..., value)

{
  name = i;
  accessorFuns = list('W' = VBFA_W_set, 'X' = VBFA_X_set, 'Eps' = VBFA_Eps_set, 'Alpha' = VBFA_Alpha_set, 'pheno' = VBFA_pheno_set);
  ;        idx = pmatch(name, names(accessorFuns));
  if(is.na(idx)) 
  return(callNextMethod(x, name, value));
  f = accessorFuns[[idx]];
  f(x, value);
  x;
}


);
# end of accessor method for PEER::cVBFA
setMethod('delete', '_p_PEER__cVBFA', function(obj) {delete_PEER__cVBFA(obj)})

